#!/usr/bin/env python3
"""
A secure proxy for running Lean and Lake commands remotely.

This script operates in two modes: server and client.

Server Mode:
- Listens on a TCP socket.
- Accepts connections, reads a command and arguments.
- Validates that the command is either 'lean' or 'lake'.
- Executes the command on the host machine.
- Streams the stdout and stderr back to the client.

Client Mode (used by wrapper scripts):
- Connects to the server.
- Sends a command and its arguments.
- Reads the response (stdout/stderr) from the server and prints it.
"""
import argparse
import socket
import subprocess
import sys
import json

ALLOWED_COMMANDS = ['lean', 'lake']
HOST = '0.0.0.0'
PORT = 6001

def run_server(args):
    """Server logic to listen for commands and execute them."""
    print(f"Starting lean-exec server on {args.host}:{args.port}...")
    print(f"Allowed commands: {', '.join(ALLOWED_COMMANDS)}")
    print("Press Ctrl+C to stop.")
    
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind((args.host, args.port))
        s.listen()
        while True:
            try:
                conn, addr = s.accept()
                with conn:
                    print(f"Connection from {addr}")
                    data = conn.recv(4096)
                    if not data:
                        continue
                    
                    try:
                        payload = json.loads(data.decode('utf-8'))
                        command = payload.get('command')
                        
                        if not command or command[0] not in ALLOWED_COMMANDS:
                            response = f"Error: Command not allowed: {command[0] if command else 'None'}"
                            conn.sendall(response.encode('utf-8'))
                            continue

                        process = subprocess.Popen(
                            command,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.STDOUT,
                            text=True,
                            bufsize=1,
                            universal_newlines=True
                        )
                        
                        for line in iter(process.stdout.readline, ''):
                            conn.sendall(line.encode('utf-8'))
                        
                        process.stdout.close()
                        process.wait()

                    except (json.JSONDecodeError, KeyError) as e:
                        conn.sendall(f"Error processing request: {e}".encode('utf-8'))
                    except Exception as e:
                        conn.sendall(f"Execution error: {e}".encode('utf-8'))
            except KeyboardInterrupt:
                print("\nShutting down server.")
                break
            except Exception as e:
                print(f"Server error: {e}")

def run_client(args):
    """Client logic to send a command to the server."""
    command_to_run = args.command
    if not command_to_run:
        print("Error: No command provided.", file=sys.stderr)
        sys.exit(1)

    payload = {"command": command_to_run}
    
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.connect((args.host, args.port))
            s.sendall(json.dumps(payload).encode('utf-8'))
            
            while True:
                data = s.recv(1024)
                if not data:
                    break
                sys.stdout.buffer.write(data)
                sys.stdout.flush()
    except ConnectionRefusedError:
        print(f"Error: Connection refused. Is the lean-exec server running on {args.host}:{args.port}?", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Client error: {e}", file=sys.stderr)
        sys.exit(1)

def main():
    parser = argparse.ArgumentParser(description="A secure proxy for running Lean and Lake commands remotely.")
    subparsers = parser.add_subparsers(dest='action', help='Action to perform')
    
    server_parser = subparsers.add_parser('server', help='Run the server (runs in foreground).')
    server_parser.add_argument('--host', default=HOST, help="Host to bind the server to.")
    server_parser.add_argument('--port', type=int, default=PORT, help="Port to listen on.")
    server_parser.set_defaults(func=run_server)
    
    client_parser = subparsers.add_parser('exec', help='Execute a remote command.')
    client_parser.add_argument('--host', default='host.docker.internal', help="Server host to connect to.")
    client_parser.add_argument('--port', type=int, default=PORT, help="Server port to connect to.")
    client_parser.add_argument('command', nargs=argparse.REMAINDER, help='The command to execute, e.g., lean --version')
    client_parser.set_defaults(func=run_client)

    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        sys.exit(1)

    args = parser.parse_args()
    args.func(args)

if __name__ == '__main__':
    main()
