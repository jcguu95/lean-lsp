#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import logging
import os
import shlex
import signal
import socket
import subprocess
import sys
import threading
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Callable

VERSION = "0.1.0"
DEFAULT_SERVER_CMD = "lake serve"
DEFAULT_DAEMON_TIMEOUT = 30
DEFAULT_START_WAIT = 30
DEFAULT_SERVER_HOST = "127.0.0.1"
DEFAULT_PORT = 9123


def resolve_address(
    host_arg: str | None, port_arg: int | None
) -> tuple[str, int]:
    host = host_arg or os.environ.get("LEAN_LSP_HOST")
    port_str = (
        str(port_arg) if port_arg is not None else os.environ.get("LEAN_LSP_PORT")
    )
    if not port_str:
        port = DEFAULT_PORT
    else:
        try:
            port = int(port_str)
        except (TypeError, ValueError) as exc:
            raise ValueError("port must be an integer") from exc
    return host, port


def load_json_arg(
    value: str | None, *, default: Any = None, label: str = "value"
) -> Any:
    if value is None:
        return default
    try:
        if value == "-":
            data = sys.stdin.read()
            if not data.strip():
                return default
            return json.loads(data)
        if value.startswith("@"):
            path = Path(value[1:]).expanduser()
            data = path.read_text(encoding="utf-8")
            return json.loads(data)
        return json.loads(value)
    except (OSError, json.JSONDecodeError) as exc:
        raise ValueError(f"{label} must be valid JSON: {exc}") from exc


def json_dumps(value: Any, *, pretty: bool = False) -> str:
    if pretty:
        return json.dumps(value, ensure_ascii=False, indent=2)
    return json.dumps(value, ensure_ascii=False)


@dataclass(frozen=True)
class DaemonConfig:
    address: tuple[str, int]
    root_dir: Path
    server_cmd: str
    timeout: int
    capabilities: dict[str, Any]
    log_level: str
    log_file: str | None
    pid_file: str | None


def setup_logging(level: str, log_file: str | None) -> logging.Logger:
    level_map = {
        "debug": logging.DEBUG,
        "info": logging.INFO,
        "warning": logging.WARNING,
        "error": logging.ERROR,
    }
    log_level = level_map.get(level, logging.INFO)
    handlers: list[logging.Handler] = []
    if log_file:
        handlers.append(logging.FileHandler(log_file, encoding="utf-8"))
    else:
        handlers.append(logging.StreamHandler())
    logging.basicConfig(
        level=log_level,
        handlers=handlers,
        format="%(asctime)s %(levelname)s %(message)s",
    )
    return logging.getLogger("lean-lsp")


def send_message(in_fp, msg: dict[str, Any], write_lock: threading.Lock) -> None:
    body = json.dumps(msg, separators=(",", ":"), ensure_ascii=False).encode("utf-8")
    header = f"Content-Length: {len(body)}\r\n\r\n".encode("ascii")
    with write_lock:
        in_fp.write(header + body)
        in_fp.flush()


def read_message(out_fp) -> dict[str, Any] | None:
    headers: dict[str, str] = {}
    while True:
        line = out_fp.readline()
        if not line:
            return None
        if line in (b"\r\n", b"\n"):
            break
        if b":" not in line:
            continue
        key, value = line.split(b":", 1)
        headers[key.decode("ascii", errors="ignore").lower()] = value.strip().decode(
            "ascii", errors="ignore"
        )
    length_str = headers.get("content-length")
    if not length_str:
        return None
    try:
        length = int(length_str)
    except ValueError:
        return None
    body = b""
    while len(body) < length:
        chunk = out_fp.read(length - len(body))
        if not chunk:
            return None
        body += chunk
    try:
        return json.loads(body.decode("utf-8"))
    except json.JSONDecodeError:
        return None


class LspConnection:
    def __init__(self, in_fp, out_fp, logger: logging.Logger):
        self.in_fp = in_fp
        self.out_fp = out_fp
        self.logger = logger
        self.write_lock = threading.Lock()
        self.responses: dict[int, dict[str, Any]] = {}
        self.responses_cv = threading.Condition()
        self.closed = False
        self._next_id = 1
        self._reader_thread = threading.Thread(target=self._reader_loop, daemon=True)

    def start(self) -> None:
        self._reader_thread.start()

    def next_id(self) -> int:
        value = self._next_id
        self._next_id += 1
        return value

    def send(self, msg: dict[str, Any]) -> None:
        if self.closed:
            raise RuntimeError("LSP connection closed")
        try:
            send_message(self.in_fp, msg, self.write_lock)
        except BrokenPipeError:
            with self.responses_cv:
                self.closed = True
                self.responses_cv.notify_all()
            raise RuntimeError("LSP connection closed (broken pipe)")

    def notify(self, method: str, params: dict[str, Any] | None) -> None:
        msg: dict[str, Any] = {"jsonrpc": "2.0", "method": method}
        if params is not None:
            msg["params"] = params
        self.send(msg)

    def request(
        self, method: str, params: dict[str, Any] | None, timeout: int
    ) -> tuple[Any, Any | None]:
        if self.closed:
            return None, "LSP connection closed"
        req_id = self.next_id()
        msg: dict[str, Any] = {"jsonrpc": "2.0", "id": req_id, "method": method}
        if params is not None:
            msg["params"] = params
        try:
            self.send(msg)
        except RuntimeError as exc:
            return None, str(exc)
        resp = self.wait_for_response(req_id, timeout)
        if resp is None:
            return None, f"{method} timed out"
        if "error" in resp:
            return None, resp["error"]
        return resp.get("result"), None

    def wait_for_response(self, target_id: int, timeout: int) -> dict[str, Any] | None:
        deadline = time.monotonic() + timeout
        with self.responses_cv:
            while True:
                if target_id in self.responses:
                    return self.responses.pop(target_id)
                if self.closed:
                    return None
                remaining = deadline - time.monotonic()
                if remaining <= 0:
                    return None
                self.responses_cv.wait(timeout=remaining)

    def _reader_loop(self) -> None:
        while True:
            msg = read_message(self.out_fp)
            if msg is None:
                with self.responses_cv:
                    self.closed = True
                    self.responses_cv.notify_all()
                return
            if "id" in msg and "method" in msg:
                try:
                    self.send({"jsonrpc": "2.0", "id": msg["id"], "result": None})
                except RuntimeError:
                    return
                continue
            if "id" in msg:
                with self.responses_cv:
                    self.responses[msg["id"]] = msg
                    self.responses_cv.notify_all()
            elif "method" in msg:
                self.logger.debug("LSP notification: %s", msg.get("method"))


def initialize_server(
    conn: LspConnection,
    root_dir: Path,
    capabilities: dict[str, Any],
    timeout: int,
) -> None:
    init_id = conn.next_id()
    conn.send(
        {
            "jsonrpc": "2.0",
            "id": init_id,
            "method": "initialize",
            "params": {
                "processId": os.getpid(),
                "rootUri": root_dir.as_uri(),
                "rootPath": str(root_dir),
                "capabilities": capabilities,
            },
        }
    )
    resp = conn.wait_for_response(init_id, timeout)
    if resp is None:
        raise RuntimeError("initialize timed out")
    if "error" in resp:
        raise RuntimeError(f"initialize error: {resp['error']}")
    conn.notify("initialized", {})


def start_server(command: list[str], cwd: Path) -> subprocess.Popen:
    if not command:
        raise RuntimeError("server command is empty")
    try:
        proc = subprocess.Popen(
            command,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=None,
            cwd=str(cwd),
            bufsize=0,
        )
    except FileNotFoundError as exc:
        raise RuntimeError(f"failed to start server: {exc}") from exc
    if proc.stdin is None or proc.stdout is None:
        raise RuntimeError("server stdio not available")
    return proc


def stop_process(proc: subprocess.Popen, timeout: int = 5) -> None:
    if proc.poll() is not None:
        return
    proc.terminate()
    try:
        proc.wait(timeout=timeout)
    except subprocess.TimeoutExpired:
        proc.kill()
        proc.wait(timeout=timeout)


def read_client_payload(conn: socket.socket, max_bytes: int = 10 * 1024 * 1024) -> str | None:
    chunks: list[bytes] = []
    total = 0
    while True:
        data = conn.recv(4096)
        if not data:
            break
        chunks.append(data)
        total += len(data)
        if total > max_bytes:
            return None
    if not chunks:
        return None
    return b"".join(chunks).decode("utf-8", errors="replace").strip()


def dispatch_op(
    op: dict[str, Any],
    lsp_conn: LspConnection,
    default_timeout: int,
    stop_event: threading.Event,
) -> dict[str, Any]:
    op_type = op.get("op")
    if op_type == "ping":
        return {"ok": True, "result": {"status": "ok"}}
    if op_type == "shutdown":
        stop_event.set()
        return {"ok": True, "result": {"status": "shutting down"}}
    if op_type == "notify":
        method = op.get("method")
        if not isinstance(method, str) or not method:
            return {"ok": False, "error": "notify requires method"}
        params = op.get("params")
        try:
            lsp_conn.notify(method, params)
        except RuntimeError as exc:
            return {"ok": False, "error": str(exc)}
        return {"ok": True, "result": None}
    if op_type == "request":
        method = op.get("method")
        if not isinstance(method, str) or not method:
            return {"ok": False, "error": "request requires method"}
        params = op.get("params")
        timeout = op.get("timeout", default_timeout)
        try:
            timeout = int(timeout)
        except (TypeError, ValueError):
            return {"ok": False, "error": "timeout must be integer seconds"}
        result, err = lsp_conn.request(method, params, timeout)
        if err:
            return {"ok": False, "error": err}
        return {"ok": True, "result": result}
    return {"ok": False, "error": f"unknown op: {op_type}"}


def handle_client_request(
    req: dict[str, Any],
    lsp_conn: LspConnection,
    default_timeout: int,
    stop_event: threading.Event,
) -> dict[str, Any]:
    if not isinstance(req, dict):
        return {"ok": False, "error": "request must be a JSON object"}
    if req.get("op") == "batch":
        ops = req.get("ops")
        if not isinstance(ops, list):
            return {"ok": False, "error": "batch requires ops list"}
        results: list[dict[str, Any]] = []
        for index, op in enumerate(ops):
            if not isinstance(op, dict):
                return {
                    "ok": False,
                    "error": {"index": index, "message": "op must be object"},
                    "results": results,
                }
            res = dispatch_op(op, lsp_conn, default_timeout, stop_event)
            results.append(res)
            if not res.get("ok"):
                return {
                    "ok": False,
                    "error": {"index": index, "message": res.get("error")},
                    "results": results,
                }
        return {"ok": True, "result": results}
    return dispatch_op(req, lsp_conn, default_timeout, stop_event)


def serve(
    lsp_conn: LspConnection,
    address: tuple[str, int],
    timeout: int,
    stop_event: threading.Event,
    server_proc: subprocess.Popen | None,
    logger: logging.Logger,
) -> None:
    host, port = address
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(address)
    server.listen(5)
    server.settimeout(1.0)
    logger.info("listening on %s:%s", host, port)

    try:
        while not stop_event.is_set():
            if server_proc is not None and server_proc.poll() is not None:
                logger.error("LSP server exited")
                stop_event.set()
                break
            if lsp_conn.closed:
                logger.error("LSP connection closed")
                stop_event.set()
                break
            try:
                client, _ = server.accept()
            except socket.timeout:
                continue
            with client:
                payload = read_client_payload(client)
                if not payload:
                    continue
                try:
                    req = json.loads(payload)
                except json.JSONDecodeError:
                    resp = {"ok": False, "error": "invalid JSON"}
                    client.sendall(json_dumps(resp).encode("utf-8"))
                    continue
                resp = handle_client_request(req, lsp_conn, timeout, stop_event)
                client.sendall(json_dumps(resp).encode("utf-8"))
    finally:
        server.close()


def ping_socket(address: tuple[str, int], timeout: float = 1.0) -> bool:
    payload = json.dumps({"op": "ping"}, separators=(",", ":")).encode("utf-8")
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.settimeout(timeout)
            sock.connect(address)
            sock.sendall(payload)
            sock.shutdown(socket.SHUT_WR)
            chunks: list[bytes] = []
            while True:
                chunk = sock.recv(4096)
                if not chunk:
                    break
                chunks.append(chunk)
        if not chunks:
            return False
        resp = json.loads(b"".join(chunks).decode("utf-8"))
        return bool(resp.get("ok"))
    except (OSError, json.JSONDecodeError):
        return False


def is_daemon_running(address: tuple[str, int]) -> bool:
    return ping_socket(address)


def run_daemon(config: DaemonConfig) -> int:
    logger = setup_logging(config.log_level, config.log_file)
    address = config.address
    if is_daemon_running(address):
        logger.info("daemon already running at %s:%s", *address)
        return 0

    root_dir = config.root_dir.resolve()
    if "lake" in config.server_cmd and not (
        (root_dir / "lakefile.lean").exists()
        or (root_dir / "lakefile.toml").exists()
    ):
        logger.error(
            "error: no lakefile.lean or lakefile.toml found in %s. "
            "Please run from a Lean project directory, or use the --root option.",
            root_dir,
        )
        return 1

    server_cmd = shlex.split(config.server_cmd)
    try:
        proc = start_server(server_cmd, root_dir)
    except RuntimeError as exc:
        logger.error(str(exc))
        return 1

    lsp_conn = LspConnection(proc.stdin, proc.stdout, logger)
    lsp_conn.start()
    try:
        initialize_server(lsp_conn, root_dir, config.capabilities, config.timeout)
    except RuntimeError as exc:
        logger.error(str(exc))
        stop_process(proc)
        return 1

    if config.pid_file:
        try:
            Path(config.pid_file).write_text(f"{os.getpid()}\n", encoding="utf-8")
        except OSError as exc:
            logger.error("failed to write pid file: %s", exc)
            stop_process(proc)
            return 1

    stop_event = threading.Event()

    def handle_signal(_signum, _frame):
        stop_event.set()

    signal.signal(signal.SIGINT, handle_signal)
    signal.signal(signal.SIGTERM, handle_signal)

    try:
        serve(lsp_conn, config.address, config.timeout, stop_event, proc, logger)
    finally:
        stop_event.set()
        if not lsp_conn.closed:
            lsp_conn.request("shutdown", None, config.timeout)
            try:
                lsp_conn.notify("exit", None)
            except RuntimeError:
                pass
        stop_process(proc)
    return 0


def wait_for_daemon(address: tuple[str, int], wait_seconds: int) -> bool:
    deadline = time.monotonic() + wait_seconds
    while time.monotonic() < deadline:
        if is_daemon_running(address):
            return True
        time.sleep(0.2)
    return False


def spawn_daemon(config: DaemonConfig, verbose: bool = False) -> subprocess.Popen:
    script_path = Path(__file__).resolve()
    host, port = config.address
    cmd = [
        sys.executable,
        str(script_path),
        "daemon",
        "--host",
        host,
        "--port",
        str(port),
        "--server-cmd",
        config.server_cmd,
        "--timeout",
        str(config.timeout),
        "--capabilities",
        json.dumps(config.capabilities, separators=(",", ":"), ensure_ascii=False),
        "--log-level",
        "debug" if verbose else config.log_level,
    ]
    if config.root_dir:
        cmd.extend(["--root", str(config.root_dir)])
    if config.log_file:
        cmd.extend(["--log-file", config.log_file])
    if config.pid_file:
        cmd.extend(["--pid-file", config.pid_file])
    stdout = None if verbose else subprocess.DEVNULL
    stderr = None if verbose else subprocess.DEVNULL
    return subprocess.Popen(
        cmd,
        stdout=stdout,
        stderr=stderr,
        stdin=subprocess.DEVNULL,
        start_new_session=True,
    )


def daemon_config_from_args(
    args: argparse.Namespace, host: str, port: int
) -> DaemonConfig:
    try:
        capabilities = load_json_arg(args.capabilities, default={}, label="capabilities")
    except ValueError as exc:
        raise RuntimeError(str(exc)) from exc
    root_dir = Path(args.root).resolve() if args.root else Path.cwd().resolve()
    return DaemonConfig(
        address=(host, port),
        root_dir=root_dir,
        server_cmd=args.server_cmd,
        timeout=args.timeout,
        capabilities=capabilities,
        log_level=args.log_level,
        log_file=args.log_file,
        pid_file=args.pid_file,
    )


def start_daemon(
    config: DaemonConfig, wait_seconds: int, foreground: bool, verbose: bool = False
) -> int:
    if is_daemon_running(config.address):
        print("already running")
        return 0

    if foreground:
        return run_daemon(config)

    print("starting daemon...")
    spawn_daemon(config, verbose=verbose)
    if wait_for_daemon(config.address, wait_seconds):
        print("started")
        return 0
    print("daemon failed to start", file=sys.stderr)
    return 1




def send_payload(
    address: tuple[str, int], payload: dict[str, Any], read_timeout: float | None
) -> dict[str, Any]:
    data = json.dumps(payload, separators=(",", ":"), ensure_ascii=False).encode("utf-8")
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            if read_timeout is not None:
                sock.settimeout(read_timeout)
            sock.connect(address)
            sock.sendall(data)
            sock.shutdown(socket.SHUT_WR)
            chunks: list[bytes] = []
            while True:
                chunk = sock.recv(4096)
                if not chunk:
                    break
                chunks.append(chunk)
    except OSError as exc:
        raise RuntimeError(f"socket connect failed: {exc}") from exc
    if not chunks:
        raise RuntimeError("no response from daemon")
    try:
        return json.loads(b"".join(chunks).decode("utf-8"))
    except json.JSONDecodeError as exc:
        raise RuntimeError(f"invalid response from daemon: {exc}") from exc


def send_request(
    address: tuple[str, int], method: str, params: dict[str, Any] | None, timeout: int
) -> Any:
    payload: dict[str, Any] = {"op": "request", "method": method, "timeout": timeout}
    if params is not None:
        payload["params"] = params
    resp = send_payload(address, payload, read_timeout=timeout + 5)
    if not resp.get("ok"):
        raise RuntimeError(resp.get("error", "unknown error"))
    return resp.get("result")


def send_notify(
    address: tuple[str, int], method: str, params: dict[str, Any] | None, timeout: int
) -> None:
    payload: dict[str, Any] = {"op": "notify", "method": method}
    if params is not None:
        payload["params"] = params
    resp = send_payload(address, payload, read_timeout=timeout + 5)
    if not resp.get("ok"):
        raise RuntimeError(resp.get("error", "unknown error"))


def did_open_params(file_path: Path, language_id: str, version: int) -> dict[str, Any]:
    return {
        "textDocument": {
            "uri": file_path.as_uri(),
            "languageId": language_id,
            "version": version,
            "text": file_path.read_text(encoding="utf-8"),
        }
    }


def did_close_params(file_path: Path) -> dict[str, Any]:
    return {"textDocument": {"uri": file_path.as_uri()}}


def with_open_file(
    address: tuple[str, int],
    file_path: Path,
    language_id: str,
    version: int,
    timeout: int,
    wait_for_diagnostics: bool,
    action: Callable[[str], Any],
) -> Any:
    send_notify(
        address,
        "textDocument/didOpen",
        did_open_params(file_path, language_id, version),
        timeout,
    )
    if wait_for_diagnostics:
        send_request(
            address,
            "textDocument/waitForDiagnostics",
            {"uri": file_path.as_uri(), "version": version},
            timeout,
        )
    try:
        return action(file_path.as_uri())
    finally:
        try:
            send_notify(address, "textDocument/didClose", did_close_params(file_path), timeout)
        except RuntimeError:
            pass


def strip_tagged_text(node: Any) -> str:
    if node is None:
        return ""
    if isinstance(node, str):
        return node
    if isinstance(node, list):
        return "".join(strip_tagged_text(item) for item in node)
    if isinstance(node, dict):
        if "text" in node:
            return str(node.get("text", ""))
        if "append" in node:
            return "".join(strip_tagged_text(item) for item in node.get("append", []))
        if "tag" in node:
            tag_val = node.get("tag")
            if isinstance(tag_val, list) and len(tag_val) == 2:
                return strip_tagged_text(tag_val[1])
            return strip_tagged_text(tag_val)
        if len(node) == 1:
            key, value = next(iter(node.items()))
            if key == "text":
                return str(value)
            if key == "append":
                return "".join(strip_tagged_text(item) for item in value)
            if key == "tag":
                if isinstance(value, list) and len(value) == 2:
                    return strip_tagged_text(value[1])
                return strip_tagged_text(value)
    return ""


def hover_contents_text(contents: Any) -> str:
    if contents is None:
        return ""
    if isinstance(contents, str):
        return contents
    if isinstance(contents, dict):
        if "value" in contents:
            return str(contents.get("value", ""))
        if "language" in contents and "value" in contents:
            return str(contents.get("value", ""))
        return json_dumps(contents, pretty=True)
    if isinstance(contents, list):
        parts = [hover_contents_text(item) for item in contents]
        return "\n".join(part for part in parts if part)
    return str(contents)


def format_range(range_obj: Any) -> str:
    if not isinstance(range_obj, dict):
        return "?"
    start = range_obj.get("start") or {}
    end = range_obj.get("end") or {}
    try:
        s_line = int(start.get("line", 0)) + 1
        s_col = int(start.get("character", 0)) + 1
        e_line = int(end.get("line", 0)) + 1
        e_col = int(end.get("character", 0)) + 1
    except (TypeError, ValueError):
        return "?"
    return f"{s_line}:{s_col}-{e_line}:{e_col}"


def severity_label(value: Any) -> str:
    return {
        1: "error",
        2: "warning",
        3: "info",
        4: "hint",
    }.get(value, "unknown")


def position_in_range(line0: int, col0: int, range_obj: Any) -> bool:
    if not isinstance(range_obj, dict):
        return True
    start = range_obj.get("start") or {}
    end = range_obj.get("end") or {}
    try:
        s_line = int(start.get("line", 0))
        s_col = int(start.get("character", 0))
        e_line = int(end.get("line", 0))
        e_col = int(end.get("character", 0))
    except (TypeError, ValueError):
        return True
    if line0 < s_line or (line0 == s_line and col0 < s_col):
        return False
    if line0 > e_line or (line0 == e_line and col0 >= e_col):
        return False
    return True


def filter_diagnostics(diagnostics: Any, line0: int, col0: int) -> Any:
    if not isinstance(diagnostics, list):
        return diagnostics
    filtered = []
    for diag in diagnostics:
        if not isinstance(diag, dict):
            continue
        range_obj = diag.get("fullRange") or diag.get("fullRange?") or diag.get("range")
        if range_obj and position_in_range(line0, col0, range_obj):
            filtered.append(diag)
    return filtered


def format_diagnostic(diag: Any) -> str:
    if not isinstance(diag, dict):
        return str(diag)
    range_obj = diag.get("fullRange") or diag.get("fullRange?") or diag.get("range")
    severity = severity_label(diag.get("severity"))
    message = strip_tagged_text(diag.get("message"))
    range_str = format_range(range_obj)
    if message:
        return f"[{severity}] {range_str} {message}"
    return f"[{severity}] {range_str}"


def print_diagnostics(diagnostics: Any) -> None:
    if not diagnostics:
        print("Diagnostics: none")
        return
    print(f"Diagnostics ({len(diagnostics)}):")
    for diag in diagnostics:
        print(format_diagnostic(diag))


def render_output(mode: str, result: Any, as_json: bool, pretty: bool) -> None:
    if as_json:
        print(json_dumps(result, pretty=pretty))
        return
    if mode == "hover":
        if result is None:
            print("null")
        elif isinstance(result, dict):
            text = hover_contents_text(result.get("contents"))
            if text:
                print(text)
            else:
                print(json_dumps(result, pretty=pretty))
        else:
            print(str(result))
        return
    if mode == "plainGoal":
        if result is None:
            print("null")
        elif isinstance(result, dict):
            print(result.get("rendered", ""))
        else:
            print(str(result))
        return
    if mode == "plainTermGoal":
        if result is None:
            print("null")
        elif isinstance(result, dict):
            print(result.get("goal", ""))
        else:
            print(str(result))
        return
    if mode == "diagnostics":
        print_diagnostics(result)
        return
    if not isinstance(result, dict):
        print(json_dumps(result, pretty=pretty))
        return
    print("Plain goal:")
    plain_goal = result.get("plainGoal")
    if plain_goal is None:
        print("null")
    else:
        print(plain_goal.get("rendered", ""))
    print("")
    print("Term goal:")
    term_goal = result.get("plainTermGoal")
    if term_goal is None:
        print("null")
    else:
        print(term_goal.get("goal", ""))
    print("")
    print_diagnostics(result.get("diagnostics"))


def add_daemon_args(parser: argparse.ArgumentParser) -> None:
    parser.add_argument(
        "--root",
        default=None,
        help="Root directory for LSP initialize (default: cwd)",
    )
    parser.add_argument(
        "--server-cmd",
        default=DEFAULT_SERVER_CMD,
        help="Command to start Lean LSP server (default: 'lake serve')",
    )
    parser.add_argument(
        "--timeout",
        type=int,
        default=DEFAULT_DAEMON_TIMEOUT,
        help="Seconds to wait for LSP responses (default: 30)",
    )
    parser.add_argument(
        "--capabilities",
        default="{}",
        help="JSON or @file for initialize capabilities (default: {})",
    )
    parser.add_argument("--pid-file", default=None, help="Write PID to file")
    parser.add_argument(
        "--log-level",
        default="info",
        choices=["debug", "info", "warning", "error"],
        help="Log level (default: info)",
    )
    parser.add_argument(
        "--log-file", default=None, help="Write logs to file instead of stderr"
    )


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Lean LSP daemon and client.")
    parser.add_argument("--pretty", action="store_true", help="Pretty-print JSON output")
    parser.add_argument("--version", action="version", version=f"lean-lsp {VERSION}")

    conn_parser = argparse.ArgumentParser(add_help=False)
    conn_parser.add_argument(
        "--host",
        default=None,
        help="Host for TCP socket (default: $LEAN_LSP_HOST, or 127.0.0.1 for server)",
    )
    conn_parser.add_argument(
        "--port",
        type=int,
        default=None,
        help=f"Port for TCP socket (default: $LEAN_LSP_PORT or {DEFAULT_PORT})",
    )

    subparsers = parser.add_subparsers(dest="command", required=True)

    start_parser = subparsers.add_parser(
        "start", help="Start the daemon", parents=[conn_parser]
    )
    add_daemon_args(start_parser)
    start_parser.add_argument(
        "--wait",
        type=int,
        default=DEFAULT_START_WAIT,
        help="Seconds to wait for daemon readiness (default: 30)",
    )
    start_parser.add_argument(
        "--foreground",
        action="store_true",
        help="Run the daemon in the foreground",
    )
    start_parser.add_argument(
        "--verbose", action="store_true", help="Show daemon logs for debugging"
    )

    subparsers.add_parser(
        "check", help="Check whether the daemon is reachable", parents=[conn_parser]
    )
    subparsers.add_parser(
        "stop", help="Ask the daemon to shut down", parents=[conn_parser]
    )

    request_parser = subparsers.add_parser(
        "request", help="Send a raw LSP request", parents=[conn_parser]
    )
    request_parser.add_argument("--method", required=True, help="LSP method name")
    request_parser.add_argument(
        "--params", default="{}", help="JSON params, @file, or - for stdin"
    )
    request_parser.add_argument(
        "--timeout", type=int, default=30, help="LSP request timeout in seconds"
    )
    request_parser.add_argument(
        "--result-only", action="store_true", help="Print only the LSP result"
    )
    request_parser.add_argument(
        "--open",
        action="store_true",
        help="Open the file before the request and close after",
    )
    request_parser.add_argument("--file", help="File path for --open")
    request_parser.add_argument(
        "--language-id", default="lean", help="Language ID for didOpen"
    )
    request_parser.add_argument(
        "--version-id", type=int, default=1, help="Document version for didOpen"
    )
    request_parser.add_argument(
        "--wait-for-diagnostics",
        action="store_true",
        help="Wait for diagnostics before the request",
    )

    notify_parser = subparsers.add_parser(
        "notify", help="Send an LSP notification", parents=[conn_parser]
    )
    notify_parser.add_argument("--method", required=True, help="LSP method name")
    notify_parser.add_argument(
        "--params", default=None, help="JSON params, @file, or - for stdin"
    )
    notify_parser.add_argument(
        "--timeout", type=int, default=10, help="Socket timeout in seconds"
    )

    batch_parser = subparsers.add_parser(
        "batch", help="Send a batch of daemon ops", parents=[conn_parser]
    )
    batch_parser.add_argument(
        "--ops", required=True, help="JSON list of ops, @file, or - for stdin"
    )
    batch_parser.add_argument(
        "--timeout",
        type=int,
        default=None,
        help="Default timeout applied to request ops",
    )
    batch_parser.add_argument(
        "--result-only", action="store_true", help="Print only the batch results"
    )

    def add_position_args(p: argparse.ArgumentParser) -> None:
        p.add_argument("file", help="Lean file path")
        p.add_argument("line", type=int, help="1-based line number")
        p.add_argument("col", type=int, help="1-based column number")
        p.add_argument(
            "--timeout", type=int, default=30, help="LSP request timeout in seconds"
        )
        p.add_argument("--json", action="store_true", help="Print JSON output")
        p.add_argument(
            "--no-wait",
            action="store_true",
            help="Skip waitForDiagnostics before request",
        )

    add_position_args(
        subparsers.add_parser("plain-goal", help="Lean plain goal", parents=[conn_parser])
    )
    add_position_args(
        subparsers.add_parser(
            "plain-term-goal", help="Lean plain term goal", parents=[conn_parser]
        )
    )
    add_position_args(
        subparsers.add_parser("hover", help="Lean hover", parents=[conn_parser])
    )
    add_position_args(
        subparsers.add_parser("diagnostics", help="Lean diagnostics", parents=[conn_parser])
    )
    add_position_args(
        subparsers.add_parser(
            "all", help="Lean goals + diagnostics", parents=[conn_parser]
        )
    )

    daemon_parser = subparsers.add_parser(
        "daemon", help=argparse.SUPPRESS, parents=[conn_parser]
    )
    add_daemon_args(daemon_parser)

    return parser.parse_args()


def main() -> int:
    args = parse_args()
    try:
        host, port = resolve_address(args.host, args.port)
    except ValueError as exc:
        print(str(exc), file=sys.stderr)
        return 2

    if args.command == "daemon":
        if host is None:
            host = DEFAULT_SERVER_HOST
        try:
            config = daemon_config_from_args(args, host, port)
        except RuntimeError as exc:
            print(str(exc), file=sys.stderr)
            return 2
        return run_daemon(config)

    if args.command == "start":
        if host is None:
            host = DEFAULT_SERVER_HOST
        try:
            config = daemon_config_from_args(args, host, port)
        except RuntimeError as exc:
            print(str(exc), file=sys.stderr)
            return 2
        return start_daemon(config, args.wait, args.foreground, args.verbose)

    if args.command == "check":
        if host is None:
            print("host is required for check", file=sys.stderr)
            return 2
        if is_daemon_running((host, port)):
            print("ok")
            return 0
        print("not running", file=sys.stderr)
        return 1

    if args.command == "stop":
        if host is None:
            print("host is required for stop", file=sys.stderr)
            return 2
        if not is_daemon_running((host, port)):
            print("not running")
            return 0
        try:
            resp = send_payload((host, port), {"op": "shutdown"}, read_timeout=5.0)
        except RuntimeError as exc:
            print(str(exc), file=sys.stderr)
            return 1
        if resp.get("ok"):
            print("stopped")
            return 0
        print(resp.get("error", "unknown error"), file=sys.stderr)
        return 1

    is_client_command = args.command in [
        "notify",
        "batch",
        "request",
        "plain-goal",
        "plain-term-goal",
        "hover",
        "diagnostics",
        "all",
    ]
    if is_client_command:
        if host is None:
            print("host is required for client commands", file=sys.stderr)
            return 2
        if not is_daemon_running((host, port)):
            print(f"daemon not running at {host}:{port}", file=sys.stderr)
            return 1

    address = (host, port)

    if args.command == "notify":
        try:
            params = load_json_arg(args.params, default=None, label="params")
            send_notify(address, args.method, params, args.timeout)
        except (RuntimeError, ValueError) as exc:
            print(str(exc), file=sys.stderr)
            return 1
        print("ok")
        return 0

    if args.command == "batch":
        try:
            ops = load_json_arg(args.ops, default=None, label="ops")
        except ValueError as exc:
            print(str(exc), file=sys.stderr)
            return 2
        if not isinstance(ops, list):
            print("ops must be a JSON list", file=sys.stderr)
            return 2
        if args.timeout is not None:
            for op in ops:
                if isinstance(op, dict) and op.get("op") == "request":
                    op.setdefault("timeout", args.timeout)
        try:
            resp = send_payload(address, {"op": "batch", "ops": ops}, read_timeout=None)
        except RuntimeError as exc:
            print(str(exc), file=sys.stderr)
            return 1
        if args.result_only:
            if not resp.get("ok"):
                print(resp.get("error", "unknown error"), file=sys.stderr)
                return 1
            print(json_dumps(resp.get("result"), pretty=args.pretty))
            return 0
        print(json_dumps(resp, pretty=args.pretty))
        return 0

    if args.command == "request":
        try:
            params = load_json_arg(args.params, default={}, label="params")
        except ValueError as exc:
            print(str(exc), file=sys.stderr)
            return 2
        if args.open and not args.file:
            print("--open requires --file", file=sys.stderr)
            return 2
        if args.wait_for_diagnostics and not args.open:
            print("--wait-for-diagnostics requires --open", file=sys.stderr)
            return 2
        try:
            if args.open:
                file_path = Path(args.file).resolve()
                if not file_path.exists():
                    print(f"file not found: {file_path}", file=sys.stderr)
                    return 2

                def action(_uri: str) -> Any:
                    return send_request(address, args.method, params, args.timeout)

                result = with_open_file(
                    address,
                    file_path,
                    args.language_id,
                    args.version_id,
                    args.timeout,
                    args.wait_for_diagnostics,
                    action,
                )
            else:
                result = send_request(address, args.method, params, args.timeout)
        except RuntimeError as exc:
            print(str(exc), file=sys.stderr)
            return 1
        if args.result_only:
            print(json_dumps(result, pretty=args.pretty))
        else:
            print(json_dumps({"ok": True, "result": result}, pretty=args.pretty))
        return 0

    file_path = Path(args.file).resolve()
    if args.line < 1 or args.col < 1:
        print("line and col must be 1-based positive integers", file=sys.stderr)
        return 2
    if not file_path.exists():
        print(f"file not found: {file_path}", file=sys.stderr)
        return 2

    line0 = args.line - 1
    col0 = args.col - 1
    wait_for_diagnostics = not args.no_wait

    try:
        if args.command == "plain-goal":

            def action(uri: str) -> Any:
                return send_request(
                    address,
                    "$/lean/plainGoal",
                    {
                        "textDocument": {"uri": uri},
                        "position": {"line": line0, "character": col0},
                    },
                    args.timeout,
                )

            result = with_open_file(
                address,
                file_path,
                "lean",
                1,
                args.timeout,
                wait_for_diagnostics,
                action,
            )
            render_output("plainGoal", result, args.json, args.pretty)
            return 0

        if args.command == "plain-term-goal":

            def action(uri: str) -> Any:
                return send_request(
                    address,
                    "$/lean/plainTermGoal",
                    {
                        "textDocument": {"uri": uri},
                        "position": {"line": line0, "character": col0},
                    },
                    args.timeout,
                )

            result = with_open_file(
                address,
                file_path,
                "lean",
                1,
                args.timeout,
                wait_for_diagnostics,
                action,
            )
            render_output("plainTermGoal", result, args.json, args.pretty)
            return 0

        if args.command == "hover":

            def action(uri: str) -> Any:
                return send_request(
                    address,
                    "textDocument/hover",
                    {
                        "textDocument": {"uri": uri},
                        "position": {"line": line0, "character": col0},
                    },
                    args.timeout,
                )

            result = with_open_file(
                address,
                file_path,
                "lean",
                1,
                args.timeout,
                wait_for_diagnostics,
                action,
            )
            render_output("hover", result, args.json, args.pretty)
            return 0

        if args.command == "diagnostics":

            def action(uri: str) -> Any:
                session = send_request(
                    address, "$/lean/rpc/connect", {"uri": uri}, args.timeout
                )
                session_id = (
                    session.get("sessionId") if isinstance(session, dict) else None
                )
                if session_id is None:
                    raise RuntimeError("rpc/connect missing sessionId")
                diagnostics = send_request(
                    address,
                    "$/lean/rpc/call",
                    {
                        "textDocument": {"uri": uri},
                        "position": {"line": line0, "character": col0},
                        "sessionId": session_id,
                        "method": "Lean.Widget.getInteractiveDiagnostics",
                        "params": {"lineRange": {"start": line0, "end": line0 + 1}},
                    },
                    args.timeout,
                )
                return filter_diagnostics(diagnostics, line0, col0)

            result = with_open_file(
                address,
                file_path,
                "lean",
                1,
                args.timeout,
                wait_for_diagnostics,
                action,
            )
            render_output("diagnostics", result, args.json, args.pretty)
            return 0

        if args.command == "all":

            def action(uri: str) -> Any:
                plain_goal = send_request(
                    address,
                    "$/lean/plainGoal",
                    {
                        "textDocument": {"uri": uri},
                        "position": {"line": line0, "character": col0},
                    },
                    args.timeout,
                )
                term_goal = send_request(
                    address,
                    "$/lean/plainTermGoal",
                    {
                        "textDocument": {"uri": uri},
                        "position": {"line": line0, "character": col0},
                    },
                    args.timeout,
                )
                session = send_request(
                    address, "$/lean/rpc/connect", {"uri": uri}, args.timeout
                )
                session_id = (
                    session.get("sessionId") if isinstance(session, dict) else None
                )
                if session_id is None:
                    raise RuntimeError("rpc/connect missing sessionId")
                diagnostics = send_request(
                    address,
                    "$/lean/rpc/call",
                    {
                        "textDocument": {"uri": uri},
                        "position": {"line": line0, "character": col0},
                        "sessionId": session_id,
                        "method": "Lean.Widget.getInteractiveDiagnostics",
                        "params": {"lineRange": {"start": line0, "end": line0 + 1}},
                    },
                    args.timeout,
                )
                diagnostics = filter_diagnostics(diagnostics, line0, col0)
                return {
                    "plainGoal": plain_goal,
                    "plainTermGoal": term_goal,
                    "diagnostics": diagnostics,
                }

            result = with_open_file(
                address,
                file_path,
                "lean",
                1,
                args.timeout,
                wait_for_diagnostics,
                action,
            )
            render_output("all", result, args.json, args.pretty)
            return 0
    except RuntimeError as exc:
        print(str(exc), file=sys.stderr)
        return 1

    print("unknown command", file=sys.stderr)
    return 2


if __name__ == "__main__":
    raise SystemExit(main())
